# goit-algo-hw-03

# Домашнє завдання до теми “Рекурсивні функції, алгоритми та приклади їх застосування”

## Завдання 1: Рекурсивне сортування файлів
**Мета:** *Написати програму на Python, яка рекурсивно копіює файли з вихідної директорії до директорії призначення, сортуючи їх у піддиректорії за розширенням файлів.*

### Ключові аспекти:

1. **Парсинг аргументів командного рядка:** Шлях до вихідної директорії та шлях до директорії призначення (за замовчуванням `dist`). 
2. **Рекурсивне читання директорій:** Функція, що обробляє директорію та викликає себе для вкладених директорій. 
3. **Копіювання файлів:** Файли копіюються у піддиректорії в теці призначення, названі відповідно до їх розширень. 
4. **Обробка винятків:** Забезпечення коректної роботи при помилках доступу. 

#### Розв`язок:
```python
import argparse
import shutil
from pathlib import Path

def parse_arguments():
    """Парсить аргументи командного рядка."""
    parser = argparse.ArgumentParser(description="Рекурсивно копіює та сортує файли за розширенням.")
    parser.add_argument("source_dir", type=Path, help="Шлях до вихідної директорії.")
    parser.add_argument("dest_dir", type=Path, nargs='?', default=Path("dist"), \
                        help="Шлях до директорії призначення (за замовчуванням 'dist').")
    return parser.parse_args()

def copy_and_sort_files(source_path: Path, dest_path: Path):
    """
    Рекурсивно обробляє директорії та копіює файли, сортуючи їх за розширенням.

    Args:
        source_path (Path): Поточний шлях у вихідній директорії.
        dest_path (Path): Шлях до базової директорії призначення.
    """
    try:
        for item in source_path.iterdir(): # Перебираємо всі елементи у директорії [cite: 12]
            if item.is_dir():
                # Рекурсивний виклик для піддиректорії [cite: 12]
                # Файли з піддиректорій також сортуються у головну директорію призначення
                copy_and_sort_files(item, dest_path)
            elif item.is_file(): # Якщо елемент є файлом, він має бути доступним для копіювання [cite: 13]
                file_extension = item.suffix[1:]  # Отримуємо розширення без крапки (e.g., 'txt', 'jpg')
                if not file_extension: # Файли без розширення
                    file_extension = "no_extension"

                # Створюємо піддиректорію для розширення у директорії призначення [cite: 14]
                extension_dir = dest_path / file_extension
                extension_dir.mkdir(parents=True, exist_ok=True)

                # Копіюємо файл [cite: 14]
                shutil.copy2(item, extension_dir / item.name)
                print(f"Скопійовано: {item} -> {extension_dir / item.name}")

    except FileNotFoundError:
        print(f"Помилка: Директорію {source_path} не знайдено.")
    except PermissionError:
        print(f"Помилка: Немає доступу до {source_path} або його вмісту.")
    except Exception as e:
        print(f"Виникла непередбачувана помилка при обробці {source_path}: {e}")

def main():
    args = parse_arguments()
    source_directory = args.source_dir
    destination_directory = args.dest_dir

    print(f"Вихідна директорія: {source_directory}")
    print(f"Директорія призначення: {destination_directory}")

    if not source_directory.exists() or not source_directory.is_dir():
        print(f"Помилка: Вихідна директорія '{source_directory}' не існує або не є директорією.")
        return

    try:
        destination_directory.mkdir(parents=True, exist_ok=True) # Створюємо директорію призначення, якщо її немає
        copy_and_sort_files(source_directory, destination_directory)
        print("Копіювання та сортування завершено.")
    except Exception as e:
        print(f"Загальна помилка під час виконання: {e}") # Обробка винятків [cite: 15]

if __name__ == "__main__":
    main()
```
#### Пояснення:
- Функція `parse_arguments` відповідає за обробку аргументів командного рядка. 
- Основна рекурсивна логіка міститься у функції `copy_and_sort_files`.
	- **Базовий випадок (неявний):** Рекурсія припиняється, коли у директорії більше немає елементів для обробки або коли обробляється файл.
	- **Рекурсивний крок:** Якщо елемент є директорією, функція викликає сама себе для цієї директорії.  Файли з усіх вкладених директорій копіюються та сортуються у відповідні підпапки в головній директорії призначення.
	- Для кожного файлу визначається його розширення, створюється відповідна піддиректорія в директорії призначення (якщо ще не існує), і файл копіюється туди.
- Використовується `pathlib` для зручної роботи зі шляхами та `shutil.copy2` для копіювання файлів зі збереженням метаданих.
- Реалізовано обробку основних винятків, таких як `FileNotFoundError` та `PermissionError`.

------------


## Завдання 2: Фрактал «Сніжинка Коха»
**Мета:** *Написати програму на Python, яка використовує рекурсію для створення фрактала «Сніжинка Коха», де користувач може вказати рівень рекурсії.*

### Ключові аспекти:

- Використання рекурсії для побудови сегментів кривої Коха.
- Можливість задати рівень рекурсії (глибину).
- Візуалізація за допомогою модуля` turtle`.

#### Розв'язок:
```python
import turtle

def koch_curve(t: turtle.Turtle, order: int, size: float):
    """
    Малює сегмент кривої Коха.

    Args:
        t (turtle.Turtle): Об'єкт turtle для малювання.
        order (int): Рівень рекурсії.
        size (float): Довжина сегмента.
    """
    if order == 0: # Базовий випадок рекурсії [cite: 35]
        t.forward(size)
    else: # Рекурсивний випадок [cite: 36]
        # Кожен сегмент ділиться на 4 менших з відповідними поворотами
        # Це відповідає класичному побудуванню кривої Коха, де середній сегмент замінюється "шипом"
        # Див. опис побудови фракталів [cite: 56] та приклад кривої Коха [cite: 152, 153]
        size_third = size / 3.0
        koch_curve(t, order - 1, size_third)
        t.left(60)
        koch_curve(t, order - 1, size_third)
        t.right(120)
        koch_curve(t, order - 1, size_third)
        t.left(60)
        koch_curve(t, order - 1, size_third)

def draw_koch_snowflake(order: int, size: float = 300.0):
    """
    Малює сніжинку Коха, яка складається з трьох кривих Коха.
    """
    window = turtle.Screen()
    window.bgcolor("white")
    window.setup(width=800, height=600)

    t = turtle.Turtle()
    t.speed(0)  # Найвища швидкість
    t.hideturtle()
    t.penup()
    # Позиціонування для центрування сніжинки
    t.goto(-size / 2, size / (2 * (3**0.5))) # Приблизний центр для рівностороннього трикутника
    t.pendown()
    t.pencolor("blue")

    for _ in range(3): # Сніжинка Коха складається з 3-х кривих Коха [cite: 154]
        koch_curve(t, order, size)
        t.right(120) # Поворот для наступної сторони сніжинки

    window.mainloop()

def main():
    while True:
        try:
            recursion_level = int(input("Введіть рівень рекурсії для сніжинки Коха (наприклад, 0-5): "))
            if recursion_level < 0:
                print("Рівень рекурсії не може бути від'ємним. Спробуйте ще раз.")
            else:
                break
        except ValueError:
            print("Будь ласка, введіть ціле число.")

    draw_koch_snowflake(recursion_level)

if __name__ == "__main__":
    main()
```
#### Пояснення:
- Функція `koch_curve` рекурсивно малює один сегмент кривої Коха.
	- **Базовий випадок:** Якщо `order` (рівень рекурсії) дорівнює `0`, черепашка просто малює пряму лінію заданої довжини. 
	- **Рекурсивний крок:** Якщо `order > 0`, лінія ділиться на три частини. Замість середньої частини малюється "зубець", що складається з двох сторін рівностороннього трикутника. Це досягається чотирма рекурсивними викликами `koch_curve` з `order - 1` та відповідними поворотами черепашки. 

- Функція `draw_koch_snowflake` налаштовує екран та черепашку, а потім викликає `koch_curve` тричі, повертаючи черепашку на 120 градусів після кожного сегменту, щоб сформувати сніжинку (рівносторонній трикутник, сторони якого є кривими Коха).
- Користувачу пропонується ввести рівень рекурсії.

------------


## Завдання 3: Ханойські вежі (необов`язкове)
**Мета:** *Написати програму, яка рекурсивно вирішує головоломку "Ханойські вежі" та виводить кожен крок переміщення дисків.* 

### Правила:

1. За один крок можна перемістити тільки один диск. 
2. Диск можна класти тільки на більший диск або на порожній стрижень.

    **Вхідні дані:** Кількість дисків `n`.

    **Вихідні дані:** Послідовність кроків для переміщення дисків зі стрижня `А` на стрижень `С`, використовуючи `В` як допоміжний. 

#### Розв'язок:
```python
def hanoi_towers(n: int, source_peg: str, auxiliary_peg: str, target_peg: str):
    """
    Рекурсивно вирішує головоломку "Ханойські вежі" та друкує кроки.

    Args:
        n (int): Кількість дисків.
        source_peg (str): Назва початкового стрижня (наприклад, 'A').
        auxiliary_peg (str): Назва допоміжного стрижня (наприклад, 'B').
        target_peg (str): Назва цільового стрижня (наприклад, 'C').
    """
    # Базовий випадок рекурсії: якщо залишився 1 диск, перемістити його напряму [cite: 35]
    if n == 1:
        print(f"Перемістити диск 1 з {source_peg} на {target_peg}")
        return

    # Рекурсивний крок [cite: 36]
    # 1. Перемістити n-1 дисків з початкового на допоміжний стрижень,
    #    використовуючи цільовий як тимчасовий.
    hanoi_towers(n - 1, source_peg, target_peg, auxiliary_peg)

    # 2. Перемістити найбільший (n-й) диск з початкового на цільовий стрижень.
    print(f"Перемістити диск {n} з {source_peg} на {target_peg}")

    # 3. Перемістити n-1 дисків з допоміжного на цільовий стрижень,
    #    використовуючи початковий як тимчасовий.
    hanoi_towers(n - 1, auxiliary_peg, source_peg, target_peg)

def main():
    while True:
        try:
            num_disks = int(input("Введіть кількість дисків для Ханойських веж (наприклад, 3): ")) # Вхідними даними програми має бути число n [cite: 20]
            if num_disks <= 0:
                print("Кількість дисків має бути додатним цілим числом.")
            else:
                break
        except ValueError:
            print("Будь ласка, введіть ціле число.")

    print(f"\nКроки для переміщення {num_disks} дисків з A на C, використовуючи B:")
    # Викликаємо функцію для переміщення дисків з A на C, використовуючи B [cite: 17, 18]
    hanoi_towers(num_disks, 'A', 'B', 'C')

if __name__ == "__main__":
    main()
```
#### Пояснення:

- Функція `hanoi_towers` реалізує класичний рекурсивний алгоритм:
	- **Базовий випадок:** Якщо потрібно перемістити лише один диск (`n == 1`), він переміщується безпосередньо з початкового стрижня на цільовий. 
	- **Рекурсивний крок (`n > 1`):**
		1. Перемістити `n-1` верхніх дисків з початкового стрижня (`source_peg`) на допоміжний (`auxiliary_peg`), використовуючи цільовий (`target_peg`) як тимчасове сховище. Це робиться рекурсивним викликом.
		2. Перемістити найбільший, `n`-й диск (який залишився на початковому стрижні) на цільовий стрижень (`target_peg`). Цей крок друкується.
		3. Перемістити `n-1` дисків з допоміжного стрижня (`auxiliary_peg`) на цільовий (`target_peg`), використовуючи початковий (`source_peg`) як тимчасове сховище. Це також рекурсивний виклик.
- Програма запитує у користувача кількість дисків. 
- Виводяться кроки, що відповідають правилам гри.  Приклад виводу для 3 дисків має збігатися з наведеним у завданні.

------------
